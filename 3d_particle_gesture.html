<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>3D ç²’å­æ‰‹åŠ¿äº¤äº’</title>
<style>
body { margin:0; overflow:hidden; background:#050505; font-family:sans-serif; color:white; }
#canvas-container { width:100vw; height:100vh; position:absolute; top:0; left:0; }
#input-video { display:none; }
#loader { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:100; text-align:center; background:rgba(0,0,0,0.8); padding:20px; border-radius:10px; }
#ui-panel { position:absolute; bottom:30px; left:50%; transform:translateX(-50%); z-index:10; background:rgba(255,255,255,0.1); backdrop-filter:blur(10px); padding:15px 25px; border-radius:20px; display:flex; gap:15px; align-items:center; }
.shape-btn { background:transparent; border:1px solid rgba(255,255,255,0.4); color:white; padding:8px 16px; border-radius:8px; cursor:pointer; transition:0.3s; }
.shape-btn:hover, .shape-btn.active { background:rgba(255,255,255,0.2); border-color:white; transform:translateY(-2px); }
input[type="color"] { background:none; border:none; width:32px; height:32px; cursor:pointer; }
#fullscreen-btn { position:absolute; top:20px; right:20px; z-index:10; background:rgba(255,255,255,0.1); border:none; color:white; padding:10px; border-radius:8px; cursor:pointer; backdrop-filter:blur(5px); }
#hand-status { position:absolute; top:20px; left:20px; z-index:10; font-size:12px; opacity:0.7; }
.status-dot { display:inline-block; width:10px; height:10px; border-radius:50%; background:red; margin-right:5px; }
.active-hand { background:#00ff00; }
</style>
</head>
<body>

<div id="loader">
    <h3>ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</h3>
    <p>æ­£åœ¨åŠ è½½ AI æ¨¡å‹ä¸ 3D å¼•æ“</p >
    <p style="font-size:12px;color:#aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿äº¤äº’</p >
</div>

<div id="hand-status">
    <span class="status-dot" id="cam-dot"></span> <span id="status-text">æ‘„åƒå¤´æœªè¿æ¥</span>
    <br>æ‰‹åŠ¿æ§åˆ¶: å¼ å¼€æ‰‹æŒ=æ‰©æ•£ | æåˆ=è¿˜åŸ
</div>

<button id="fullscreen-btn">â›¶ å…¨å±</button>

<div id="canvas-container"></div>
<video id="input-video" autoplay playsinline muted></video>

<div id="ui-panel">
    <button class="shape-btn active" onclick="changeShape('heart')">â¤ï¸ çˆ±å¿ƒ</button>
    <button class="shape-btn" onclick="changeShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
    <button class="shape-btn" onclick="changeShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
    <button class="shape-btn" onclick="changeShape('buddha')">ğŸ§˜ ä½›åƒ</button>
    <button class="shape-btn" onclick="changeShape('fireworks')">ğŸ† çƒŸèŠ±</button>
    <div style="width:1px;height:20px;background:rgba(255,255,255,0.3); margin:0 5px;"></div>
    ç²’å­è‰²:<input type="color" id="colorPicker" value="#ff88cc">
</div>

<script type="module">
import * as THREE from 'https://cdn.staticfile.org/three.js/r136/three.module.min.js';
import { OrbitControls } from 'https://cdn.staticfile.org/three.js/r136/examples/jsm/controls/OrbitControls.min.js';
import { Hands } from 'https://cdn.staticfile.org/mediapipe/0.5.0/hands.js';
import { Camera } from 'https://cdn.staticfile.org/mediapipe/0.5.0/camera_utils.js';

let scene, camera, renderer, particles, controls;
let positions=[], targetPositions=[];
let particleCount=20000;
let handInteractionFactor=0;
const loaderEl=document.getElementById('loader');
const statusText=document.getElementById('status-text');
const camDot=document.getElementById('cam-dot');

// =================== Three.js åˆå§‹åŒ– ===================
function initThree(){
    const container=document.getElementById('canvas-container');
    scene=new THREE.Scene();
    scene.fog=new THREE.FogExp2(0x050505,0.002);
    camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
    camera.position.z=100;
    renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true;
    controls.autoRotate=true;
    controls.autoRotateSpeed=0.5;

    createParticles();
    window.addEventListener('resize',onWindowResize);

    document.getElementById('colorPicker').addEventListener('input',e=>{
        particles.material.color.set(e.target.value)
    });
    document.getElementById('fullscreen-btn').addEventListener('click',()=>{
        if(!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    });
    animate();
}

// =================== ç²’å­ç³»ç»Ÿ ===================
function createParticles(){
    const geometry=new THREE.BufferGeometry();
    positions=new Float32Array(particleCount*3);
    targetPositions=new Float32Array(particleCount*3);
    const heartPoints=generateHeart(particleCount);
    for(let i=0;i<particleCount;i++){
        positions[i*3]=(Math.random()-0.5)*200;
        positions[i*3+1]=(Math.random()-0.5)*200;
        positions[i*3+2]=(Math.random()-0.5)*200;

        targetPositions[i*3]=heartPoints[i*3];
        targetPositions[i*3+1]=heartPoints[i*3+1];
        targetPositions[i*3+2]=heartPoints[i*3+2];
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const material=new THREE.PointsMaterial({
        color:0xff88cc,size:0.8,transparent:true,opacity:0.8,blending:THREE.AdditiveBlending,depthWrite:false
    });
    particles=new THREE.Points(geometry,material);
    scene.add(particles);
}

// =================== å½¢çŠ¶ç”Ÿæˆå‡½æ•° ===================
// ä¸ä¹‹å‰ç¤ºä¾‹ç›¸åŒï¼ŒåŒ…æ‹¬ generateHeart, generateSphere, generateFlower, generateSaturn, generateBuddha, generateFireworks

function generateHeart(count){
    const arr=new Float32Array(count*3);
    for(let i=0;i<count;i++){
        let t=Math.random()*Math.PI*2;
        let u=Math.random()+Math.random();
        let x=16*Math.pow(Math.sin(t),3);
        let y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        let z=(Math.random()-0.5)*10;
        let scale=Math.sqrt(Math.random());
        arr[i*3]=x*scale*2; arr[i*3+1]=y*scale*2; arr[i*3+2]=z*scale*2;
    }
    return arr;
}

function generateSphere(count,radius){const arr=new Float32Array(count*3);for(let i=0;i<count;i++){const theta=Math.random()*Math.PI*2;const phi=Math.acos((Math.random()*2)-1);const rr=Math.cbrt(Math.random())*radius;arr[i*3]=rr*Math.sin(phi)*Math.cos(theta);arr[i*3+1]=rr*Math.sin(phi)*Math.sin(theta);arr[i*3+2]=rr*Math.cos(phi);}return arr;}
function generateFlower(count){const arr=new Float32Array(count*3);const phi=Math.PI*(3-Math.sqrt(5));for(let i=0;i<count;i++){const y=1-(i/(count-1))*2;const radius=Math.sqrt(1-y*y);const theta=phi*i;const r=radius*40*(1+0.5*Math.sin(theta*5));arr[i*3]=Math.cos(theta)*r;arr[i*3+1]=y*20;arr[i*3+2]=Math.sin(theta)*r;}return arr;}
function generateSaturn(count){const arr=new Float32Array(count*3);const ringCount=Math.floor(count*0.4);const sphereCount=count-ringCount;for(let i=0;i<sphereCount;i++){const theta=Math.random()*Math.PI*2;const phi=Math.acos((Math.random()*2)-1);const r=Math.cbrt(Math.random())*25;arr[i*3]=r*Math.sin(phi)*Math.cos(theta);arr[i*3+1]=r*Math.sin(phi)*Math.sin(theta);arr[i*3+2]=r*Math.cos(phi);}for(let i=sphereCount;i<count;i++){const angle=Math.random()*Math.PI*2;const dist=35+Math.random()*25;arr[i*3]=Math.cos(angle)*dist;arr[i*3+1]=(Math.random()-0.5)*2;arr[i*3+2]=Math.sin(angle)*dist;const x=arr[i*3],y=arr[i*3+1];const tilt=0.4;arr[i*3]=x*Math.cos(tilt)-y*Math.sin(tilt);arr[i*3+1]=x*Math.sin(tilt)+y*Math.cos(tilt);}return arr;}
function generateBuddha(count){const arr=new Float32Array(count*3);let idx=0;const addSphere=(cx,cy,cz,radius,pts)=>{for(let k=0;k<pts;k++){if(idx>=count) break;const theta=Math.random()*Math.PI*2;const phi=Math.acos((Math.random()*2)-1);const r=Math.cbrt(Math.random())*radius;arr[idx*3]=cx+r*Math.sin(phi)*Math.cos(theta);arr[idx*3+1]=cy+r*Math.sin(phi)*Math.sin(theta);arr[idx*3+2]=cz+r*Math.cos(phi);idx++;}};addSphere(0,25,0,8,Math.floor(count*0.15));addSphere(0,5,0,14,Math.floor(count*0.35));for(let k=0;k<count*0.5;k++){if(idx>=count) break;const angle=Math.random()*Math.PI*2;const r=Math.random()*22;arr[idx*3]=Math.cos(angle)*r;arr[idx*3+1]=-10+(Math.random()-0.5)*8;arr[idx*3+2]=Math.sin(angle)*r;idx++;}return arr;}
function generateFireworks(count){return generateSphere(count,5);}

// =================== åˆ‡æ¢å½¢çŠ¶ ===================
window.changeShape=function(shapeName){
    let newPoints; const btns=document.querySelectorAll('.shape-btn'); btns.forEach(b=>b.classList.remove('active')); event.target.classList.add('active');
    if(shapeName==='heart') newPoints=generateHeart(particleCount);
    else if(shapeName==='flower') newPoints=generateFlower(particleCount);
    else if(shapeName==='saturn') newPoints=generateSaturn(particleCount);
    else if(shapeName==='buddha') newPoints=generateBuddha(particleCount);
    else if(shapeName==='fireworks') newPoints=generateFireworks(particleCount);
    for(let i=0;i<particleCount*3;i++) targetPositions[i]=newPoints[i];
}

// =================== MediaPipe Hands ===================
async function initMediaPipe(){
    const videoElement=document.getElementById('input-video');
    const hands=new Hands({locateFile:file=>`https://cdn.staticfile.org/mediapipe/0.5.0/${file}`});
    hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
    hands.onResults(onHandsResults);
    const cameraUtils=new Camera(videoElement,{onFrame:async()=>{await hands.send({image:videoElement})},width:640,height:480});
    try{await cameraUtils.start(); loaderEl.style.display='none'; statusText.innerText="æ‘„åƒå¤´è¿è¡Œä¸­ - è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹æŒ"; camDot.classList.add('active-hand');}catch(e){console.error(e); loaderEl.innerHTML="<h3>æ— æ³•å¯åŠ¨æ‘„åƒå¤´</h3><p>è¯·æ£€æŸ¥æƒé™æˆ–ä½¿ç”¨HTTPS/localhostç¯å¢ƒ</p >";}
}

// =================== æ‰‹åŠ¿è¯†åˆ«å›è°ƒ ===================
function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];

        // è·å–æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)
        const thumb = landmarks[4];
        const index = landmarks[8];

        // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦» (å¿½ç•¥ Z è½´)
        const distance = Math.sqrt(
            Math.pow(thumb.x - index.x, 2) + 
            Math.pow(thumb.y - index.y, 2)
        );

        // æ˜ å°„è·ç¦»åˆ° 0-1
        let factor = (distance - 0.05) / (0.2 - 0.05);
        factor = Math.max(0, Math.min(1, factor)); // Clamp

        // å¹³æ»‘è¿‡æ¸¡
        handInteractionFactor += (factor - handInteractionFactor) * 0.1;

        statusText.innerText = `æ‰‹åŠ¿æ£€æµ‹ä¸­: ${Math.round(handInteractionFactor * 100)}% æ‰©æ•£`;
    } else {
        // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œç¼“æ…¢å¤åŸ
        handInteractionFactor += (0 - handInteractionFactor) * 0.05;
        statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
    }
}

// =================== åŠ¨ç”»å¾ªç¯ ===================
function animate() {
    requestAnimationFrame(animate);

    if (particles) {
        const posAttr = particles.geometry.attributes.position;
        const arr = posAttr.array;

        controls.update();

        for (let i = 0; i < particleCount; i++) {
            const idx = i * 3;

            // 1. å½¢çŠ¶å˜å½¢ (Morphing)
            arr[idx]     += (targetPositions[idx]     - arr[idx])     * 0.05;
            arr[idx + 1] += (targetPositions[idx + 1] - arr[idx + 1]) * 0.05;
            arr[idx + 2] += (targetPositions[idx + 2] - arr[idx + 2]) * 0.05;

            // 2. æ‰‹åŠ¿äº¤äº’ (æ‰©æ•£/å™ªéŸ³)
            if (handInteractionFactor > 0.01) {
                const explosion = 50 * handInteractionFactor;
                const x = arr[idx], y = arr[idx + 1], z = arr[idx + 2];
                const len = Math.sqrt(x*x + y*y + z*z) + 0.001;

                arr[idx]     += (x / len) * explosion + (Math.random() - 0.5) * explosion * 0.5;
                arr[idx + 1] += (y / len) * explosion + (Math.random() - 0.5) * explosion * 0.5;
                arr[idx + 2] += (z / len) * explosion + (Math.random() - 0.5) * explosion * 0.5;
            }
        }

        posAttr.needsUpdate = true;

        // ç¼“æ…¢æ—‹è½¬ç²’å­ç¾¤
        particles.rotation.y += 0.001;
    }

    renderer.render(scene, camera);
}

// =================== çª—å£ç¼©æ”¾ ===================
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// =================== å¯åŠ¨ ===================
initThree();
initMediaPipe();
</script>
</body>
</html>
